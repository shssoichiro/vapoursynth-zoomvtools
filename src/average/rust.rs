use std::num::NonZeroUsize;

use crate::util::Pixel;

/// Averages two images pixel by pixel, blending them together.
///
/// This function takes two source images and computes the average of corresponding
/// pixels, storing the result in the destination buffer. The averaging uses ceiling
/// division to ensure proper rounding for integer pixel values.
///
/// # Parameters
/// - `src1`: First source image buffer
/// - `src2`: Second source image buffer
/// - `dest`: Destination buffer to store the averaged result
/// - `pitch`: Number of pixels per row (including any padding)
/// - `width`: Width of the image in pixels
/// - `height`: Height of the image in pixels
///
/// # Notes
/// The C++ SIMD implementation is actually slower than the ASM generated by the compiler for
/// our naive Rust implementation. Which is impressive, because the C++ SIMD is pretty clean.
pub fn average2<T: Pixel>(
    dest: &mut [T],
    src1: &[T],
    src2: &[T],
    pitch: NonZeroUsize,
    width: NonZeroUsize,
    height: NonZeroUsize,
) {
    let mut offset = 0;
    for _j in 0..height.get() {
        for i in 0..width.get() {
            // SAFETY: Bounds are checked at top of function
            unsafe {
                match size_of::<T>() {
                    1 => {
                        // Smaller types for faster 8-bit path
                        let a: u16 = src1
                            .get_unchecked(offset + i)
                            .to_u16()
                            .expect("fits in u16");
                        let b: u16 = src2
                            .get_unchecked(offset + i)
                            .to_u16()
                            .expect("fits in u16");
                        *dest.get_unchecked_mut(offset + i) =
                            T::from_u16_or_max_value((a + b + 1) / 2);
                    }
                    2 => {
                        let a: u32 = src1
                            .get_unchecked(offset + i)
                            .to_u32()
                            .expect("fits in u32");
                        let b: u32 = src2
                            .get_unchecked(offset + i)
                            .to_u32()
                            .expect("fits in u32");
                        *dest.get_unchecked_mut(offset + i) =
                            T::from_u32_or_max_value((a + b + 1) / 2);
                    }
                    _ => unreachable!(),
                }
            }
        }
        offset += pitch.get();
    }
}
