use std::num::NonZeroUsize;

use crate::util::Pixel;

/// # Notes
/// The C++ SIMD implementation is actually slower than the ASM generated by the compiler for
/// our naive Rust implementation. Which is impressive, because the C++ SIMD is pretty clean.
pub(super) fn average2<T: Pixel>(
    dest: &mut [T],
    src1: &[T],
    src2: &[T],
    pitch: NonZeroUsize,
    width: NonZeroUsize,
    height: NonZeroUsize,
) {
    let mut offset = 0;
    for _j in 0..height.get() {
        for i in 0..width.get() {
            // SAFETY: Bounds are checked at top of function
            unsafe {
                match size_of::<T>() {
                    1 => {
                        // Smaller types for faster 8-bit path
                        let a: u16 = src1
                            .get_unchecked(offset + i)
                            .to_u16()
                            .expect("fits in u16");
                        let b: u16 = src2
                            .get_unchecked(offset + i)
                            .to_u16()
                            .expect("fits in u16");
                        *dest.get_unchecked_mut(offset + i) =
                            T::from_u16_or_max_value((a + b + 1) / 2);
                    }
                    2 => {
                        let a: u32 = src1
                            .get_unchecked(offset + i)
                            .to_u32()
                            .expect("fits in u32");
                        let b: u32 = src2
                            .get_unchecked(offset + i)
                            .to_u32()
                            .expect("fits in u32");
                        *dest.get_unchecked_mut(offset + i) =
                            T::from_u32_or_max_value((a + b + 1) / 2);
                    }
                    _ => unreachable!(),
                }
            }
        }
        offset += pitch.get();
    }
}
